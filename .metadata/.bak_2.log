!SESSION 2015-03-31 13:42:26.371 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

This is a continuation of log file C:\Users\Pieter\Documents\mario\.metadata\.bak_1.log
Created Time: 2015-03-31 19:03:45.996

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:03:45.997
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:119)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:221)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:199)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:285)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:186)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1181)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1150)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:902)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:243)
	at org.eclipse.jface.text.TextViewerHoverManager$5.run(TextViewerHoverManager.java:233)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4147)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3764)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:03:46.013
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.text.correction.ASTResolving.createQuickFixAST(ASTResolving.java:1219)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:122)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:221)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:199)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:285)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:186)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1181)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1150)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:902)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:243)
	at org.eclipse.jface.text.TextViewerHoverManager$5.run(TextViewerHoverManager.java:233)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4147)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3764)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.ui 4 0 2015-03-31 19:03:46.014
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Failed to execute runnable (java.lang.IllegalArgumentException)
	at org.eclipse.swt.SWT.error(SWT.java:4441)
	at org.eclipse.swt.SWT.error(SWT.java:4356)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:139)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4147)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3764)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
Caused by: java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.text.correction.ASTResolving.createQuickFixAST(ASTResolving.java:1219)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:122)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:221)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:199)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:285)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:186)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1181)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1150)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:902)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:243)
	at org.eclipse.jface.text.TextViewerHoverManager$5.run(TextViewerHoverManager.java:233)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)
	... 23 more

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:04:17.810
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:04:17.812
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:04:17.812
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:04:33.385
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:04:33.386
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:04:33.387
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:04:34.124
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:04:34.125
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:04:34.125
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:04:37.251
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX];
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:04:37.252
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:04:37.253
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:04:37.310
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX];
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:04:37.311
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:04:37.312
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:04:39.319
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX].ty;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:04:39.320
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:04:39.321
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:04:39.352
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX].ty;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:04:39.353
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:04:39.354
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:04:42.376
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX].tiletype;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:04:42.376
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:04:42.376
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:04:42.407
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX].tiletype;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:04:42.407
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:04:42.407
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:04:43.438
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX].tiletype;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:04:43.438
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:04:43.438
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:04:44.704
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX].tiletype;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:04:44.704
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:04:44.704
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:04:45.829
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX].tiletype;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:04:45.829
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:04:45.845
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:04:56.361
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX].tiletype;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:04:56.361
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:04:56.361
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:04:59.423
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX].tiletype;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:04:59.423
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:04:59.423
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:05:00.283
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX].tiletype;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:05:00.298
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:05:00.298
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:05:02.924
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = ;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:05:02.924
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:05:02.924
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:05:02.955
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = ;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:05:02.955
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:05:02.955
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:05:06.705
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = ;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:05:06.705
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:05:06.705
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:05:07.017
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = ;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:449)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:376)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:330)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:278)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:519)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:122)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)
	at sun.reflect.GeneratedMethodAccessor39.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:229)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:149)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1085)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1070)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1112)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1108)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1529)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4722)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:343)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4610)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:339)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5023)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3759)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:05:07.017
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:449)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:376)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:330)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:278)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:519)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:122)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)
	at sun.reflect.GeneratedMethodAccessor39.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:229)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:149)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1085)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1070)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1112)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1108)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1529)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4722)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:343)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4610)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:339)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5023)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3759)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:05:07.017
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:449)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:376)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:330)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:278)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:519)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:122)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)
	at sun.reflect.GeneratedMethodAccessor39.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:229)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:149)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1085)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1070)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1112)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1108)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1529)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4722)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:343)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4610)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:339)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5023)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3759)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:05:09.471
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = geologicalFeature[tileY][tileX];
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:05:09.471
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:05:09.471
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:05:09.486
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = geologicalFeature[tileY][tileX];
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:05:09.502
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:05:09.502
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:05:09.549
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = geologicalFeature[tileY][tileX];
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:05:09.549
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:05:09.549
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:05:11.486
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = geologicalFeature[tileY][tileX].AIR;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:05:11.486
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:05:11.486
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:05:11.502
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = geologicalFeature[tileY][tileX].AIR;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:05:11.502
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:05:11.502
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:05:12.830
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = geologicalFeature[tileY][tileX].AIR;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:05:12.830
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:05:12.830
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:05:14.283
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = geologicalFeature[tileY][tileX].AIR;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:05:14.283
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:05:14.283
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:05:28.143
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = geologicalFeature[tileY][tileX].AIR;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:05:28.143
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:05:28.143
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:05:30.972
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = geologicalFeature[tileY][tileX].AIR;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:05:30.972
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:05:30.972
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:05:33.175
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = geologicalFeature[tileY][tileX].AIR;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:05:33.175
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:05:33.175
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:05:34.159
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = geologicalFeature[tileY][tileX].AIR;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:05:34.159
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:05:34.159
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:05:36.784
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = geologicalFeature[tileY][tileX].AIR;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:05:36.784
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:05:36.784
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:05:43.082
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tile
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:05:43.082
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:05:43.082
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:05:43.113
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tile
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:05:43.113
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:05:43.113
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:05:43.144
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tile
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:05:43.144
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:05:43.144
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:05:44.597
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tiletype
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:05:44.597
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:05:44.613
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:05:44.644
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tiletype
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 19:05:44.644
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 19:05:44.644
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 19:05:50.113
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tiletype
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
