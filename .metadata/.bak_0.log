!SESSION 2015-02-19 16:56:35.566 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-02-19 16:57:35.799
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-02-19 16:57:35.800
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-02-19 17:24:36.914 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-02-19 17:24:53.878
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-02-19 17:24:53.891
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-02-21 13:25:13.122 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-02-21 13:27:51.450
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-02-21 13:27:51.452
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-02-21 13:39:56.264 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-02-21 13:40:13.192
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-02-21 13:40:13.194
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-02-22 12:20:27.559 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-02-22 12:20:45.403
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-02-22 12:20:45.432
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-02-24 13:39:29.982 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-02-24 13:39:58.240
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-02-24 13:39:58.265
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.core 4 0 2015-02-24 16:11:03.121
!MESSAGE An exception occurred during push on URI https://github.com/pietervdb/mario.git: https://github.com/pietervdb/mario.git: not authorized
!STACK 0
org.eclipse.jgit.api.errors.TransportException: https://github.com/pietervdb/mario.git: not authorized
	at org.eclipse.jgit.api.PushCommand.call(PushCommand.java:160)
	at org.eclipse.egit.core.op.PushOperation.run(PushOperation.java:228)
	at org.eclipse.egit.ui.internal.push.PushOperationUI.execute(PushOperationUI.java:167)
	at org.eclipse.egit.ui.internal.push.PushOperationUI$1.run(PushOperationUI.java:229)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Caused by: org.eclipse.jgit.errors.TransportException: https://github.com/pietervdb/mario.git: not authorized
	at org.eclipse.jgit.transport.TransportHttp.connect(TransportHttp.java:501)
	at org.eclipse.jgit.transport.TransportHttp.openPush(TransportHttp.java:399)
	at org.eclipse.jgit.transport.PushProcess.execute(PushProcess.java:154)
	at org.eclipse.jgit.transport.Transport.push(Transport.java:1173)
	at org.eclipse.jgit.api.PushCommand.call(PushCommand.java:156)
	... 4 more
!SESSION 2015-02-24 16:59:11.251 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-02-24 16:59:29.129
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-02-24 16:59:29.131
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-02-25 10:44:22.442 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-02-25 10:44:50.945
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-02-25 10:44:51.021
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-02-26 15:21:23.332 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-02-26 15:21:48.792
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-02-26 15:21:48.857
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.resources 4 4 2015-02-26 17:04:55.076
!MESSAGE Exception loading preferences from: /les_4/.settings/org.eclipse.jdt.core.prefs.
!STACK 1
org.eclipse.core.runtime.CoreException: File not found: C:\Users\Pieter\Documents\mario\les_4\.settings\org.eclipse.jdt.core.prefs.
	at org.eclipse.core.internal.filesystem.Policy.error(Policy.java:55)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:386)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.core.internal.resources.ProjectPreferences.load(ProjectPreferences.java:497)
	at org.eclipse.core.internal.resources.ProjectPreferences.load(ProjectPreferences.java:482)
	at org.eclipse.core.internal.preferences.EclipsePreferences.create(EclipsePreferences.java:409)
	at org.eclipse.core.internal.preferences.EclipsePreferences.getChild(EclipsePreferences.java:534)
	at org.eclipse.core.internal.preferences.EclipsePreferences.internalNode(EclipsePreferences.java:668)
	at org.eclipse.core.internal.preferences.EclipsePreferences.node(EclipsePreferences.java:812)
	at org.eclipse.core.resources.ProjectScope.getNode(ProjectScope.java:67)
	at org.eclipse.core.internal.preferences.PreferencesService$5.run(PreferencesService.java:613)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.preferences.PreferencesService.getNodes(PreferencesService.java:607)
	at org.eclipse.core.internal.preferences.PreferencesService.getString(PreferencesService.java:676)
	at org.eclipse.jdt.apt.core.util.AptConfig.getString(AptConfig.java:874)
	at org.eclipse.jdt.apt.core.util.AptConfig.isEnabled(AptConfig.java:718)
	at org.eclipse.jdt.apt.core.internal.generatedfile.GeneratedSourceFolderManager.<init>(GeneratedSourceFolderManager.java:99)
	at org.eclipse.jdt.apt.core.internal.AptProject.<init>(AptProject.java:37)
	at org.eclipse.jdt.apt.core.internal.AptPlugin.getAptProject(AptPlugin.java:220)
	at org.eclipse.jdt.apt.core.internal.AptPlugin.getAptProject(AptPlugin.java:231)
	at org.eclipse.jdt.apt.core.internal.generatedfile.GeneratedResourceChangeListener$PreBuildVisitor.handleDeletion(GeneratedResourceChangeListener.java:187)
	at org.eclipse.jdt.apt.core.internal.generatedfile.GeneratedResourceChangeListener$PreBuildVisitor.access$1(GeneratedResourceChangeListener.java:181)
	at org.eclipse.jdt.apt.core.internal.generatedfile.GeneratedResourceChangeListener.resourceChanged(GeneratedResourceChangeListener.java:88)
	at org.eclipse.jdt.internal.core.DeltaProcessingState$1.run(DeltaProcessingState.java:472)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.core.DeltaProcessingState.resourceChanged(DeltaProcessingState.java:467)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:291)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:285)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:149)
	at org.eclipse.core.internal.resources.Workspace.broadcastBuildEvent(Workspace.java:364)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:139)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Caused by: java.io.FileNotFoundException: C:\Users\Pieter\Documents\mario\les_4\.settings\org.eclipse.jdt.core.prefs (Het systeem kan het opgegeven pad niet vinden)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	... 33 more
!SUBENTRY 1 org.eclipse.core.filesystem 4 271 2015-02-26 17:04:55.102
!MESSAGE File not found: C:\Users\Pieter\Documents\mario\les_4\.settings\org.eclipse.jdt.core.prefs.
!STACK 0
java.io.FileNotFoundException: C:\Users\Pieter\Documents\mario\les_4\.settings\org.eclipse.jdt.core.prefs (Het systeem kan het opgegeven pad niet vinden)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.core.internal.filesystem.local.LocalFile.openInputStream(LocalFile.java:377)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:797)
	at org.eclipse.core.internal.resources.File.getContents(File.java:290)
	at org.eclipse.core.internal.resources.ProjectPreferences.load(ProjectPreferences.java:497)
	at org.eclipse.core.internal.resources.ProjectPreferences.load(ProjectPreferences.java:482)
	at org.eclipse.core.internal.preferences.EclipsePreferences.create(EclipsePreferences.java:409)
	at org.eclipse.core.internal.preferences.EclipsePreferences.getChild(EclipsePreferences.java:534)
	at org.eclipse.core.internal.preferences.EclipsePreferences.internalNode(EclipsePreferences.java:668)
	at org.eclipse.core.internal.preferences.EclipsePreferences.node(EclipsePreferences.java:812)
	at org.eclipse.core.resources.ProjectScope.getNode(ProjectScope.java:67)
	at org.eclipse.core.internal.preferences.PreferencesService$5.run(PreferencesService.java:613)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.preferences.PreferencesService.getNodes(PreferencesService.java:607)
	at org.eclipse.core.internal.preferences.PreferencesService.getString(PreferencesService.java:676)
	at org.eclipse.jdt.apt.core.util.AptConfig.getString(AptConfig.java:874)
	at org.eclipse.jdt.apt.core.util.AptConfig.isEnabled(AptConfig.java:718)
	at org.eclipse.jdt.apt.core.internal.generatedfile.GeneratedSourceFolderManager.<init>(GeneratedSourceFolderManager.java:99)
	at org.eclipse.jdt.apt.core.internal.AptProject.<init>(AptProject.java:37)
	at org.eclipse.jdt.apt.core.internal.AptPlugin.getAptProject(AptPlugin.java:220)
	at org.eclipse.jdt.apt.core.internal.AptPlugin.getAptProject(AptPlugin.java:231)
	at org.eclipse.jdt.apt.core.internal.generatedfile.GeneratedResourceChangeListener$PreBuildVisitor.handleDeletion(GeneratedResourceChangeListener.java:187)
	at org.eclipse.jdt.apt.core.internal.generatedfile.GeneratedResourceChangeListener$PreBuildVisitor.access$1(GeneratedResourceChangeListener.java:181)
	at org.eclipse.jdt.apt.core.internal.generatedfile.GeneratedResourceChangeListener.resourceChanged(GeneratedResourceChangeListener.java:88)
	at org.eclipse.jdt.internal.core.DeltaProcessingState$1.run(DeltaProcessingState.java:472)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.core.DeltaProcessingState.resourceChanged(DeltaProcessingState.java:467)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:291)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:285)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:149)
	at org.eclipse.core.internal.resources.Workspace.broadcastBuildEvent(Workspace.java:364)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:139)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.equinox.preferences 4 4 2015-02-26 17:04:55.108
!MESSAGE Exception loading preferences from: C:/Users/Pieter/Documents/mario/les_4/.settings/org.eclipse.jdt.core.prefs.
!STACK 0
org.osgi.service.prefs.BackingStoreException: Exception loading preferences from: /les_4/.settings/org.eclipse.jdt.core.prefs.
	at org.eclipse.core.internal.resources.ProjectPreferences.load(ProjectPreferences.java:505)
	at org.eclipse.core.internal.resources.ProjectPreferences.load(ProjectPreferences.java:482)
	at org.eclipse.core.internal.preferences.EclipsePreferences.create(EclipsePreferences.java:409)
	at org.eclipse.core.internal.preferences.EclipsePreferences.getChild(EclipsePreferences.java:534)
	at org.eclipse.core.internal.preferences.EclipsePreferences.internalNode(EclipsePreferences.java:668)
	at org.eclipse.core.internal.preferences.EclipsePreferences.node(EclipsePreferences.java:812)
	at org.eclipse.core.resources.ProjectScope.getNode(ProjectScope.java:67)
	at org.eclipse.core.internal.preferences.PreferencesService$5.run(PreferencesService.java:613)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.preferences.PreferencesService.getNodes(PreferencesService.java:607)
	at org.eclipse.core.internal.preferences.PreferencesService.getString(PreferencesService.java:676)
	at org.eclipse.jdt.apt.core.util.AptConfig.getString(AptConfig.java:874)
	at org.eclipse.jdt.apt.core.util.AptConfig.isEnabled(AptConfig.java:718)
	at org.eclipse.jdt.apt.core.internal.generatedfile.GeneratedSourceFolderManager.<init>(GeneratedSourceFolderManager.java:99)
	at org.eclipse.jdt.apt.core.internal.AptProject.<init>(AptProject.java:37)
	at org.eclipse.jdt.apt.core.internal.AptPlugin.getAptProject(AptPlugin.java:220)
	at org.eclipse.jdt.apt.core.internal.AptPlugin.getAptProject(AptPlugin.java:231)
	at org.eclipse.jdt.apt.core.internal.generatedfile.GeneratedResourceChangeListener$PreBuildVisitor.handleDeletion(GeneratedResourceChangeListener.java:187)
	at org.eclipse.jdt.apt.core.internal.generatedfile.GeneratedResourceChangeListener$PreBuildVisitor.access$1(GeneratedResourceChangeListener.java:181)
	at org.eclipse.jdt.apt.core.internal.generatedfile.GeneratedResourceChangeListener.resourceChanged(GeneratedResourceChangeListener.java:88)
	at org.eclipse.jdt.internal.core.DeltaProcessingState$1.run(DeltaProcessingState.java:472)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.core.DeltaProcessingState.resourceChanged(DeltaProcessingState.java:467)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:291)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:285)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:149)
	at org.eclipse.core.internal.resources.Workspace.broadcastBuildEvent(Workspace.java:364)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:139)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.ui.ide 4 4 2015-02-26 17:04:57.011
!MESSAGE Problems saving workspace

!ENTRY org.eclipse.ui.ide 2 1 2015-02-26 17:04:57.012
!MESSAGE Problems occurred while trying to save the state of the workbench.
!SUBENTRY 1 org.eclipse.core.resources 2 234 2015-02-26 17:04:57.012
!MESSAGE The project description file (.project) for 'les_4' was missing.  This file contains important information about the project.  A new project description file has been created, but some information about the project may have been lost.
!SESSION 2015-02-27 18:34:39.044 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.core.resources 2 10035 2015-02-27 18:34:41.923
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.egit.ui 2 0 2015-02-27 18:34:58.692
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-02-27 18:34:58.693
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-02-28 14:14:21.494 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-02-28 14:20:05.564
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-02-28 14:20:05.783
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-01 12:05:29.034 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-01 12:05:49.688
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-01 12:05:49.781
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-01 16:17:28.326 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-01 16:17:46.925
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-01 16:17:47.030
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-01 16:19:25.045 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-01 16:19:42.690
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-01 16:19:42.693
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-03 13:45:12.333 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-03 13:45:35.630
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-03 13:45:35.631
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-03 14:17:22.570 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-03 14:17:39.983
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-03 14:17:39.986
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-04 10:37:52.324 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-04 10:38:11.610
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-04 10:38:11.610
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-05 13:34:27.377 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-05 13:34:47.668
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-05 13:34:47.669
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-06 18:23:27.056 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-06 18:23:46.064
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-06 18:23:46.132
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-06 21:30:05.631 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-06 21:30:23.238
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-06 21:30:23.305
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.ui 4 10001 2015-03-06 21:30:34.948
!MESSAGE Internal Error
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Resource '/OGP1415-JumpingAlien/src/Mazub.java' does not exist.
	at org.eclipse.core.internal.resources.Resource.checkExists(Resource.java:341)
	at org.eclipse.core.internal.resources.Resource.checkAccessible(Resource.java:215)
	at org.eclipse.core.internal.resources.Resource.findMaxProblemSeverity(Resource.java:1051)
	at org.eclipse.jdt.ui.ProblemsLabelDecorator.getPackageErrorTicksFromMarkers(ProblemsLabelDecorator.java:337)
	at org.eclipse.jdt.ui.ProblemsLabelDecorator.computeAdornmentFlags(ProblemsLabelDecorator.java:212)
	at org.eclipse.jdt.internal.ui.viewsupport.TreeHierarchyLayoutProblemsDecorator.computePackageAdornmentFlags(TreeHierarchyLayoutProblemsDecorator.java:47)
	at org.eclipse.jdt.internal.ui.viewsupport.TreeHierarchyLayoutProblemsDecorator.computeAdornmentFlags(TreeHierarchyLayoutProblemsDecorator.java:56)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerProblemsDecorator.computeAdornmentFlags(PackageExplorerProblemsDecorator.java:35)
	at org.eclipse.jdt.ui.ProblemsLabelDecorator.decorateImage(ProblemsLabelDecorator.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.JavaUILabelProvider.decorateImage(JavaUILabelProvider.java:134)
	at org.eclipse.jdt.internal.ui.viewsupport.JavaUILabelProvider.getImage(JavaUILabelProvider.java:149)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerLabelProvider.getImage(PackageExplorerLabelProvider.java:140)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.getImage(DelegatingStyledCellLabelProvider.java:195)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.getImage(DecoratingStyledCellLabelProvider.java:173)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.update(DelegatingStyledCellLabelProvider.java:121)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.update(DecoratingStyledCellLabelProvider.java:136)
	at org.eclipse.jface.viewers.ViewerColumn.refresh(ViewerColumn.java:154)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:949)
	at org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run(AbstractTreeViewer.java:114)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:50)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:178)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:1029)
	at org.eclipse.jface.viewers.StructuredViewer$UpdateItemSafeRunnable.run(StructuredViewer.java:472)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:50)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:178)
	at org.eclipse.jface.viewers.StructuredViewer.updateItem(StructuredViewer.java:2150)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createTreeItem(AbstractTreeViewer.java:843)
	at org.eclipse.jface.viewers.AbstractTreeViewer$1.run(AbstractTreeViewer.java:818)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren(AbstractTreeViewer.java:791)
	at org.eclipse.jface.viewers.TreeViewer.createChildren(TreeViewer.java:611)
	at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren(AbstractTreeViewer.java:762)
	at org.eclipse.jface.viewers.AbstractTreeViewer.handleTreeExpand(AbstractTreeViewer.java:1495)
	at org.eclipse.jface.viewers.TreeViewer.handleTreeExpand(TreeViewer.java:903)
	at org.eclipse.jface.viewers.AbstractTreeViewer$4.treeExpanded(AbstractTreeViewer.java:1507)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:132)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4353)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1085)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1070)
	at org.eclipse.swt.widgets.Tree.wmNotifyChild(Tree.java:7633)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5618)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1935)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5169)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4666)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5023)
	at org.eclipse.swt.internal.win32.OS.CallWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(OS.java:2443)
	at org.eclipse.swt.widgets.Tree.callWindowProc(Tree.java:1553)
	at org.eclipse.swt.widgets.Tree.WM_LBUTTONDOWN(Tree.java:6501)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4646)
	at org.eclipse.swt.widgets.Tree.windowProc(Tree.java:6024)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5023)
	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3759)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
!SUBENTRY 1 org.eclipse.core.resources 4 368 2015-03-06 21:30:34.950
!MESSAGE Resource '/OGP1415-JumpingAlien/src/Mazub.java' does not exist.

!ENTRY org.eclipse.jdt.ui 4 10001 2015-03-06 21:30:35.101
!MESSAGE Internal Error
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Resource '/OGP1415-JumpingAlien/src/Mazub.java' does not exist.
	at org.eclipse.core.internal.resources.Resource.checkExists(Resource.java:341)
	at org.eclipse.core.internal.resources.Resource.checkAccessible(Resource.java:215)
	at org.eclipse.core.internal.resources.Resource.findMaxProblemSeverity(Resource.java:1051)
	at org.eclipse.jdt.ui.ProblemsLabelDecorator.getPackageErrorTicksFromMarkers(ProblemsLabelDecorator.java:337)
	at org.eclipse.jdt.ui.ProblemsLabelDecorator.computeAdornmentFlags(ProblemsLabelDecorator.java:212)
	at org.eclipse.jdt.internal.ui.viewsupport.TreeHierarchyLayoutProblemsDecorator.computePackageAdornmentFlags(TreeHierarchyLayoutProblemsDecorator.java:47)
	at org.eclipse.jdt.internal.ui.viewsupport.TreeHierarchyLayoutProblemsDecorator.computeAdornmentFlags(TreeHierarchyLayoutProblemsDecorator.java:56)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerProblemsDecorator.computeAdornmentFlags(PackageExplorerProblemsDecorator.java:35)
	at org.eclipse.jdt.ui.ProblemsLabelDecorator.decorateImage(ProblemsLabelDecorator.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.JavaUILabelProvider.decorateImage(JavaUILabelProvider.java:134)
	at org.eclipse.jdt.internal.ui.viewsupport.JavaUILabelProvider.getImage(JavaUILabelProvider.java:149)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerLabelProvider.getImage(PackageExplorerLabelProvider.java:140)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.getImage(DelegatingStyledCellLabelProvider.java:195)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.getImage(DecoratingStyledCellLabelProvider.java:173)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.update(DelegatingStyledCellLabelProvider.java:121)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.update(DecoratingStyledCellLabelProvider.java:136)
	at org.eclipse.jface.viewers.ViewerColumn.refresh(ViewerColumn.java:154)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:949)
	at org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run(AbstractTreeViewer.java:114)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:50)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:178)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:1029)
	at org.eclipse.jface.viewers.StructuredViewer$UpdateItemSafeRunnable.run(StructuredViewer.java:472)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:50)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:178)
	at org.eclipse.jface.viewers.StructuredViewer.updateItem(StructuredViewer.java:2150)
	at org.eclipse.jface.viewers.StructuredViewer.internalUpdate(StructuredViewer.java:2133)
	at org.eclipse.jface.viewers.StructuredViewer.update(StructuredViewer.java:2071)
	at org.eclipse.jface.viewers.ColumnViewer.update(ColumnViewer.java:540)
	at org.eclipse.jface.viewers.StructuredViewer.update(StructuredViewer.java:2015)
	at org.eclipse.jface.viewers.StructuredViewer.handleLabelProviderChanged(StructuredViewer.java:1182)
	at org.eclipse.jdt.internal.ui.viewsupport.ProblemTreeViewer.handleLabelProviderChanged(ProblemTreeViewer.java:223)
	at org.eclipse.jface.viewers.ContentViewer$1.labelProviderChanged(ContentViewer.java:99)
	at org.eclipse.jface.viewers.BaseLabelProvider$1.run(BaseLabelProvider.java:72)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:50)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:178)
	at org.eclipse.jface.viewers.BaseLabelProvider.fireLabelProviderChanged(BaseLabelProvider.java:69)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider$1.labelProviderChanged(DecoratingStyledCellLabelProvider.java:78)
	at org.eclipse.ui.internal.decorators.DecoratorManager$1.run(DecoratorManager.java:446)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.DecoratorManager.fireListener(DecoratorManager.java:443)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$3.runInUIThread(DecorationScheduler.java:536)
	at org.eclipse.ui.progress.UIJob$1.run(UIJob.java:97)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4147)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3764)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
!SUBENTRY 1 org.eclipse.core.resources 4 368 2015-03-06 21:30:35.102
!MESSAGE Resource '/OGP1415-JumpingAlien/src/Mazub.java' does not exist.

!ENTRY org.eclipse.jdt.ui 4 10001 2015-03-06 21:31:44.243
!MESSAGE Internal Error
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Resource '/OGP1415-JumpingAlien/src/Mazub.java' does not exist.
	at org.eclipse.core.internal.resources.Resource.checkExists(Resource.java:341)
	at org.eclipse.core.internal.resources.Resource.checkAccessible(Resource.java:215)
	at org.eclipse.core.internal.resources.Resource.findMaxProblemSeverity(Resource.java:1051)
	at org.eclipse.jdt.ui.ProblemsLabelDecorator.getPackageErrorTicksFromMarkers(ProblemsLabelDecorator.java:337)
	at org.eclipse.jdt.ui.ProblemsLabelDecorator.computeAdornmentFlags(ProblemsLabelDecorator.java:212)
	at org.eclipse.jdt.internal.ui.viewsupport.TreeHierarchyLayoutProblemsDecorator.computePackageAdornmentFlags(TreeHierarchyLayoutProblemsDecorator.java:47)
	at org.eclipse.jdt.internal.ui.viewsupport.TreeHierarchyLayoutProblemsDecorator.computeAdornmentFlags(TreeHierarchyLayoutProblemsDecorator.java:56)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerProblemsDecorator.computeAdornmentFlags(PackageExplorerProblemsDecorator.java:35)
	at org.eclipse.jdt.ui.ProblemsLabelDecorator.decorateImage(ProblemsLabelDecorator.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.JavaUILabelProvider.decorateImage(JavaUILabelProvider.java:134)
	at org.eclipse.jdt.internal.ui.viewsupport.JavaUILabelProvider.getImage(JavaUILabelProvider.java:149)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerLabelProvider.getImage(PackageExplorerLabelProvider.java:140)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.getImage(DelegatingStyledCellLabelProvider.java:195)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.getImage(DecoratingStyledCellLabelProvider.java:173)
	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.update(DelegatingStyledCellLabelProvider.java:121)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.update(DecoratingStyledCellLabelProvider.java:136)
	at org.eclipse.jface.viewers.ViewerColumn.refresh(ViewerColumn.java:154)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:949)
	at org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run(AbstractTreeViewer.java:114)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:50)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:178)
	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:1029)
	at org.eclipse.jface.viewers.StructuredViewer$UpdateItemSafeRunnable.run(StructuredViewer.java:472)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:50)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:178)
	at org.eclipse.jface.viewers.StructuredViewer.updateItem(StructuredViewer.java:2150)
	at org.eclipse.jface.viewers.StructuredViewer.internalUpdate(StructuredViewer.java:2133)
	at org.eclipse.jface.viewers.StructuredViewer.update(StructuredViewer.java:2071)
	at org.eclipse.jface.viewers.ColumnViewer.update(ColumnViewer.java:540)
	at org.eclipse.jface.viewers.StructuredViewer.update(StructuredViewer.java:2015)
	at org.eclipse.jface.viewers.StructuredViewer.handleLabelProviderChanged(StructuredViewer.java:1182)
	at org.eclipse.jdt.internal.ui.viewsupport.ProblemTreeViewer.handleLabelProviderChanged(ProblemTreeViewer.java:223)
	at org.eclipse.jface.viewers.ContentViewer$1.labelProviderChanged(ContentViewer.java:99)
	at org.eclipse.jface.viewers.BaseLabelProvider$1.run(BaseLabelProvider.java:72)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:50)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:178)
	at org.eclipse.jface.viewers.BaseLabelProvider.fireLabelProviderChanged(BaseLabelProvider.java:69)
	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider$1.labelProviderChanged(DecoratingStyledCellLabelProvider.java:78)
	at org.eclipse.ui.internal.decorators.DecoratorManager$1.run(DecoratorManager.java:446)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.DecoratorManager.fireListener(DecoratorManager.java:443)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$3.runInUIThread(DecorationScheduler.java:536)
	at org.eclipse.ui.progress.UIJob$1.run(UIJob.java:97)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4147)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3764)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
!SUBENTRY 1 org.eclipse.core.resources 4 368 2015-03-06 21:31:44.244
!MESSAGE Resource '/OGP1415-JumpingAlien/src/Mazub.java' does not exist.
!SESSION 2015-03-07 14:12:39.789 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-07 14:12:57.990
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-07 14:12:57.992
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-07 18:08:04.773 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-07 18:08:22.270
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-07 18:08:22.271
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.equinox.event 4 0 2015-03-07 19:42:54.384
!MESSAGE Exception while dispatching event org.osgi.service.event.Event [topic=org/eclipse/e4/ui/model/ui/UIElement/widget/SET] to handler org.eclipse.e4.ui.services.internal.events.UIEventHandler@15958d3
!STACK 0
java.lang.NullPointerException
	at org.eclipse.ui.internal.NavigationHistory.getDisplay(NavigationHistory.java:176)
	at org.eclipse.ui.internal.NavigationHistory.markEditor(NavigationHistory.java:193)
	at org.eclipse.ui.internal.WorkbenchPage.updateActiveEditorSources(WorkbenchPage.java:407)
	at org.eclipse.ui.internal.WorkbenchPage.firePartClosed(WorkbenchPage.java:4995)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart$1.handleEvent(CompatibilityPart.java:98)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler$1.run(UIEventHandler.java:40)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:187)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:156)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4734)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:218)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:36)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:81)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:59)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.e4.ui.model.application.ui.impl.UIElementImpl.setWidget(UIElementImpl.java:261)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer.unbindWidget(SWTPartRenderer.java:149)
	at org.eclipse.e4.ui.workbench.renderers.swt.SWTPartRenderer$1.widgetDisposed(SWTPartRenderer.java:137)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:123)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4353)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1085)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:816)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:874)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:819)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:874)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:819)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:874)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:819)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:874)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:819)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:874)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:819)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:874)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:819)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:874)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:819)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:874)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:819)
	at org.eclipse.swt.widgets.Composite.releaseChildren(Composite.java:874)
	at org.eclipse.swt.widgets.Canvas.releaseChildren(Canvas.java:165)
	at org.eclipse.swt.widgets.Decorations.releaseChildren(Decorations.java:789)
	at org.eclipse.swt.widgets.Shell.releaseChildren(Shell.java:1290)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:819)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:454)
	at org.eclipse.swt.widgets.Decorations.dispose(Decorations.java:447)
	at org.eclipse.swt.widgets.Shell.dispose(Shell.java:715)
	at org.eclipse.swt.widgets.Display.release(Display.java:3811)
	at org.eclipse.swt.graphics.Device.dispose(Device.java:295)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3292)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2544)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4705)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:339)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1626)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2075)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5036)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3141)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3756)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:832)
	at org.eclipse.jface.window.Window.open(Window.java:808)
	at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:341)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.open(MessageDialogWithToggle.java:114)
	at org.eclipse.jface.dialogs.MessageDialogWithToggle.openOkCancelConfirm(MessageDialogWithToggle.java:209)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchWindowAdvisor.promptOnExit(IDEWorkbenchWindowAdvisor.java:218)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchAdvisor$2.handleEvent(IDEWorkbenchAdvisor.java:171)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4353)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4346)
	at org.eclipse.swt.widgets.Display.messageProc(Display.java:3305)
	at org.eclipse.swt.internal.win32.OS.DefWindowProcW(Native Method)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(OS.java:2544)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:498)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4705)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:339)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1626)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2075)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5036)
	at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3141)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3756)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
!SESSION 2015-03-08 13:02:29.387 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-08 13:02:47.592
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-08 13:02:47.592
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-08 15:27:05.332 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.core.resources 2 10035 2015-03-08 15:27:09.598
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-08 15:27:27.318
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-08 15:27:27.319
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-08 16:16:55.330 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-08 16:17:12.893
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-08 16:17:12.894
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-09 18:54:17.383 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-09 18:54:39.876
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-09 18:54:39.877
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-10 13:13:31.994 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-10 13:14:01.971
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-10 13:14:01.971
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.ui 4 10001 2015-03-10 15:24:15.815
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Java Model Status [isValid [in IFacade [in [Working copy] IFacade.java [in jumpingalien.part1.facade [in src-provided [in OGP1415-JumpingAlien]]]]] does not exist]
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:534)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:568)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:294)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:280)
	at org.eclipse.jdt.internal.core.SourceRefElement.getSourceRange(SourceRefElement.java:218)
	at org.eclipse.jdt.internal.core.Member.getJavadocRange(Member.java:291)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContentFromSource(JavadocContentAccess2.java:601)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:496)
	at org.eclipse.jdt.internal.ui.infoviews.JavadocView.getJavadocHtml(JavadocView.java:1097)
	at org.eclipse.jdt.internal.ui.infoviews.JavadocView.computeInput(JavadocView.java:908)
	at org.eclipse.jdt.internal.ui.infoviews.AbstractInfoView$2.run(AbstractInfoView.java:717)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2015-03-10 15:24:15.815
!MESSAGE isValid [in IFacade [in [Working copy] IFacade.java [in jumpingalien.part1.facade [in src-provided [in OGP1415-JumpingAlien]]]]] does not exist
!SESSION 2015-03-10 19:57:32.576 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-10 19:57:52.220
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-10 19:57:52.221
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-11 10:36:34.575 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-11 10:36:58.471
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-11 10:37:00.096
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-11 16:24:58.605 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-11 16:25:18.219
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-11 16:25:18.220
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-12 12:55:05.135 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-12 12:55:24.082
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-12 12:55:24.084
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-13 10:05:33.014 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-13 10:05:52.849
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-13 10:05:53.059
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-14 10:51:29.807 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-14 10:52:20.922
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-14 10:52:20.922
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-14 10:54:29.807 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-14 10:54:46.689
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-14 10:54:46.689
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-14 11:07:22.513 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-14 11:07:39.641
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-14 11:07:39.642
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 4 2015-03-14 11:12:43.302
!MESSAGE Unable to create part

!ENTRY org.eclipse.core.filebuffers 4 0 2015-03-14 11:12:43.302
!MESSAGE Cannot determine URI for '/OGP1415-JumpingAlien/src-provided/jumpingalien/part1/facade/Facade.java'.
!STACK 1
org.eclipse.core.runtime.CoreException: Cannot determine URI for '/OGP1415-JumpingAlien/src-provided/jumpingalien/part1/facade/Facade.java'.
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.create(ResourceFileBuffer.java:238)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.connect(TextFileBufferManager.java:112)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.createFileInfo(TextFileDocumentProvider.java:559)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.createFileInfo(CompilationUnitDocumentProvider.java:980)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:478)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.connect(CompilationUnitDocumentProvider.java:1244)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4233)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:237)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1480)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2584)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2557)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1395)
	at org.eclipse.ui.texteditor.AbstractTextEditor$19.run(AbstractTextEditor.java:3220)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:466)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:374)
	at org.eclipse.ui.internal.WorkbenchWindow$13.run(WorkbenchWindow.java:2157)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2153)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3238)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3265)
	at org.eclipse.ui.internal.EditorReference.initialize(EditorReference.java:390)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:305)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:888)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:869)
	at org.eclipse.e4.core.internal.di.InjectorImpl.inject(InjectorImpl.java:120)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:337)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:258)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:162)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:104)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:73)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:55)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:127)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:983)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:662)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1250)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer$1.handleEvent(LazyStackRenderer.java:68)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler$1.run(UIEventHandler.java:40)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:187)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:156)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4734)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:218)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:36)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:81)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:59)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:171)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1251)
	at org.eclipse.ui.internal.WorkbenchPage.hidePart(WorkbenchPage.java:1599)
	at org.eclipse.ui.internal.WorkbenchPage.hidePart(WorkbenchPage.java:1550)
	at org.eclipse.ui.internal.WorkbenchPage.closeEditors(WorkbenchPage.java:1520)
	at org.eclipse.ui.internal.WorkbenchPage.closeEditor(WorkbenchPage.java:1645)
	at org.eclipse.ui.texteditor.AbstractTextEditor$23.run(AbstractTextEditor.java:4333)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4147)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3764)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
!SUBENTRY 1 org.eclipse.core.filebuffers 4 0 2015-03-14 11:12:43.318
!MESSAGE Cannot determine URI for '/OGP1415-JumpingAlien/src-provided/jumpingalien/part1/facade/Facade.java'.

!ENTRY org.eclipse.ui 4 4 2015-03-14 11:12:48.053
!MESSAGE Unable to create part

!ENTRY org.eclipse.core.filebuffers 4 0 2015-03-14 11:12:48.053
!MESSAGE Cannot determine URI for '/OGP1415-JumpingAlien/src-provided/jumpingalien/part1/facade/IFacade.java'.
!STACK 1
org.eclipse.core.runtime.CoreException: Cannot determine URI for '/OGP1415-JumpingAlien/src-provided/jumpingalien/part1/facade/IFacade.java'.
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.create(ResourceFileBuffer.java:238)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.connect(TextFileBufferManager.java:112)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.createFileInfo(TextFileDocumentProvider.java:559)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.createFileInfo(CompilationUnitDocumentProvider.java:980)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:478)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.connect(CompilationUnitDocumentProvider.java:1244)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4233)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:237)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1480)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2584)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2557)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1395)
	at org.eclipse.ui.texteditor.AbstractTextEditor$19.run(AbstractTextEditor.java:3220)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:466)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:374)
	at org.eclipse.ui.internal.WorkbenchWindow$13.run(WorkbenchWindow.java:2157)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2153)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3238)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3265)
	at org.eclipse.ui.internal.EditorReference.initialize(EditorReference.java:390)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:305)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:888)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:869)
	at org.eclipse.e4.core.internal.di.InjectorImpl.inject(InjectorImpl.java:120)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:337)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:258)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:162)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:104)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:73)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:55)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:127)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:983)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:662)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1250)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer$1.handleEvent(LazyStackRenderer.java:68)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler$1.run(UIEventHandler.java:40)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:187)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:156)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4734)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:218)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:36)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:81)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:59)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:171)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1251)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1204)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.closePart(StackRenderer.java:1222)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.access$3(StackRenderer.java:1204)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer$12.close(StackRenderer.java:1095)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1874)
	at org.eclipse.swt.custom.CTabFolder$1.handleEvent(CTabFolder.java:288)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4353)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4172)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3761)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
!SUBENTRY 1 org.eclipse.core.filebuffers 4 0 2015-03-14 11:12:48.054
!MESSAGE Cannot determine URI for '/OGP1415-JumpingAlien/src-provided/jumpingalien/part1/facade/IFacade.java'.

!ENTRY org.eclipse.ui 4 4 2015-03-14 11:12:48.468
!MESSAGE Unable to create part

!ENTRY org.eclipse.core.filebuffers 4 0 2015-03-14 11:12:48.469
!MESSAGE Cannot determine URI for '/OGP1415-JumpingAlien/tests/jumpingalien/part1/tests/PartialFacadeTest.java'.
!STACK 1
org.eclipse.core.runtime.CoreException: Cannot determine URI for '/OGP1415-JumpingAlien/tests/jumpingalien/part1/tests/PartialFacadeTest.java'.
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.create(ResourceFileBuffer.java:238)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.connect(TextFileBufferManager.java:112)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.createFileInfo(TextFileDocumentProvider.java:559)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.createFileInfo(CompilationUnitDocumentProvider.java:980)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:478)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.connect(CompilationUnitDocumentProvider.java:1244)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4233)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:237)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1480)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2584)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2557)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1395)
	at org.eclipse.ui.texteditor.AbstractTextEditor$19.run(AbstractTextEditor.java:3220)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:466)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:374)
	at org.eclipse.ui.internal.WorkbenchWindow$13.run(WorkbenchWindow.java:2157)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2153)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3238)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3265)
	at org.eclipse.ui.internal.EditorReference.initialize(EditorReference.java:390)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:305)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:888)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:869)
	at org.eclipse.e4.core.internal.di.InjectorImpl.inject(InjectorImpl.java:120)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:337)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:258)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:162)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:104)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:73)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:55)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:127)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:983)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:662)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1250)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer$1.handleEvent(LazyStackRenderer.java:68)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler$1.run(UIEventHandler.java:40)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:187)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:156)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4734)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:218)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:36)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:81)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:59)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:171)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1251)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1204)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.closePart(StackRenderer.java:1222)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.access$3(StackRenderer.java:1204)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer$12.close(StackRenderer.java:1095)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1874)
	at org.eclipse.swt.custom.CTabFolder$1.handleEvent(CTabFolder.java:288)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4353)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4172)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3761)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
!SUBENTRY 1 org.eclipse.core.filebuffers 4 0 2015-03-14 11:12:48.469
!MESSAGE Cannot determine URI for '/OGP1415-JumpingAlien/tests/jumpingalien/part1/tests/PartialFacadeTest.java'.

!ENTRY org.eclipse.ui 4 4 2015-03-14 11:12:50.029
!MESSAGE Unable to create part

!ENTRY org.eclipse.core.filebuffers 4 0 2015-03-14 11:12:50.030
!MESSAGE Cannot determine URI for '/03DefensiveProgramming/Rational.java'.
!STACK 1
org.eclipse.core.runtime.CoreException: Cannot determine URI for '/03DefensiveProgramming/Rational.java'.
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.create(ResourceFileBuffer.java:238)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.connect(TextFileBufferManager.java:112)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.createFileInfo(TextFileDocumentProvider.java:559)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.createFileInfo(CompilationUnitDocumentProvider.java:980)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:478)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.connect(CompilationUnitDocumentProvider.java:1244)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4233)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:237)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1480)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2584)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2557)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1395)
	at org.eclipse.ui.texteditor.AbstractTextEditor$19.run(AbstractTextEditor.java:3220)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:466)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:374)
	at org.eclipse.ui.internal.WorkbenchWindow$13.run(WorkbenchWindow.java:2157)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2153)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3238)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3265)
	at org.eclipse.ui.internal.EditorReference.initialize(EditorReference.java:390)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:305)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:888)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:869)
	at org.eclipse.e4.core.internal.di.InjectorImpl.inject(InjectorImpl.java:120)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:337)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:258)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:162)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:104)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:73)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:55)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:127)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:983)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:662)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1250)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer$1.handleEvent(LazyStackRenderer.java:68)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler$1.run(UIEventHandler.java:40)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:187)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:156)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4734)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:218)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:36)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:81)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:59)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:171)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1251)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1204)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.closePart(StackRenderer.java:1222)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.access$3(StackRenderer.java:1204)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer$12.close(StackRenderer.java:1095)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1874)
	at org.eclipse.swt.custom.CTabFolder$1.handleEvent(CTabFolder.java:288)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4353)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4172)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3761)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
!SUBENTRY 1 org.eclipse.core.filebuffers 4 0 2015-03-14 11:12:50.030
!MESSAGE Cannot determine URI for '/03DefensiveProgramming/Rational.java'.
!SESSION 2015-03-14 11:16:15.144 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-14 11:16:32.202
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-14 11:16:32.202
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-14 11:32:15.956 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-14 11:32:47.896
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-14 11:32:48.365
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-15 10:56:13.605 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-15 10:56:34.881
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-15 10:56:35.068
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-15 15:25:08.850 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-15 15:25:28.348
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-15 15:25:28.349
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-15 16:34:32.414 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-15 16:34:52.832
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-15 16:34:53.021
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-15 17:27:51.574 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-15 17:28:10.918
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-15 17:28:10.921
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-15 20:15:05.930 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-15 20:15:26.152
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-15 20:15:26.153
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 4 2015-03-15 22:30:02.161
!MESSAGE Unable to create part

!ENTRY org.eclipse.core.filebuffers 4 0 2015-03-15 22:30:02.162
!MESSAGE Cannot determine URI for '/OGP1415-JumpingAlien/src-provided/jumpingalien/part1/facade/Facade.java'.
!STACK 1
org.eclipse.core.runtime.CoreException: Cannot determine URI for '/OGP1415-JumpingAlien/src-provided/jumpingalien/part1/facade/Facade.java'.
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.create(ResourceFileBuffer.java:238)
	at org.eclipse.core.internal.filebuffers.TextFileBufferManager.connect(TextFileBufferManager.java:112)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.createFileInfo(TextFileDocumentProvider.java:559)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.createFileInfo(CompilationUnitDocumentProvider.java:980)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:478)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.connect(CompilationUnitDocumentProvider.java:1244)
	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:4233)
	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:237)
	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1480)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2584)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2557)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1395)
	at org.eclipse.ui.texteditor.AbstractTextEditor$19.run(AbstractTextEditor.java:3220)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:466)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:374)
	at org.eclipse.ui.internal.WorkbenchWindow$13.run(WorkbenchWindow.java:2157)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2153)
	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3238)
	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3265)
	at org.eclipse.ui.internal.EditorReference.initialize(EditorReference.java:390)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:305)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:888)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:869)
	at org.eclipse.e4.core.internal.di.InjectorImpl.inject(InjectorImpl.java:120)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:337)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:258)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:162)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:104)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:73)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:55)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:127)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:983)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:662)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:766)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$2(PartRenderingEngine.java:737)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$7.run(PartRenderingEngine.java:731)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:715)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl$1.handleEvent(PartServiceImpl.java:94)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler$1.run(UIEventHandler.java:40)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:187)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:156)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4734)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:218)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:36)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:81)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:59)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:171)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1251)
	at org.eclipse.ui.internal.WorkbenchPage.hidePart(WorkbenchPage.java:1599)
	at org.eclipse.ui.internal.WorkbenchPage.hidePart(WorkbenchPage.java:1550)
	at org.eclipse.ui.internal.WorkbenchPage.closeEditors(WorkbenchPage.java:1520)
	at org.eclipse.ui.internal.WorkbenchPage.closeEditor(WorkbenchPage.java:1645)
	at org.eclipse.ui.texteditor.AbstractTextEditor$23.run(AbstractTextEditor.java:4333)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4147)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3764)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:175)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:390)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:331)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.internalPerformFinish(RefactoringWizard.java:637)
	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.performFinish(UserInputWizardPage.java:153)
	at org.eclipse.ltk.ui.refactoring.resource.DeleteResourcesWizard$DeleteResourcesRefactoringConfigurationPage.performFinish(DeleteResourcesWizard.java:202)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.performFinish(RefactoringWizard.java:710)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.okPressed(RefactoringWizardDialog2.java:455)
	at org.eclipse.jface.dialogs.Dialog.buttonPressed(Dialog.java:466)
	at org.eclipse.jface.dialogs.Dialog$2.widgetSelected(Dialog.java:619)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:248)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4353)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4172)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3761)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:832)
	at org.eclipse.jface.window.Window.open(Window.java:808)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:187)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:202)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:122)
	at org.eclipse.ltk.internal.ui.refactoring.actions.DeleteResourcesHandler.execute(DeleteResourcesHandler.java:40)
	at org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:294)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:229)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:149)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)
	at org.eclipse.ui.internal.handlers.LegacyHandlerService.executeCommandInContext(LegacyHandlerService.java:396)
	at org.eclipse.ui.internal.ide.actions.LTKLauncher.runCommand(LTKLauncher.java:95)
	at org.eclipse.ui.internal.ide.actions.LTKLauncher.openDeleteWizard(LTKLauncher.java:47)
	at org.eclipse.ui.actions.DeleteResourceAction.run(DeleteResourceAction.java:474)
	at org.eclipse.jdt.internal.ui.refactoring.reorg.DeleteAction.run(DeleteAction.java:197)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:275)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:251)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:519)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:595)
	at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:511)
	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:420)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4353)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4172)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3761)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
!SUBENTRY 1 org.eclipse.core.filebuffers 4 0 2015-03-15 22:30:02.164
!MESSAGE Cannot determine URI for '/OGP1415-JumpingAlien/src-provided/jumpingalien/part1/facade/Facade.java'.
!SESSION 2015-03-17 15:54:00.454 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product C:\Users\Pieter\Desktop\Excel 2013.lnk
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product C:\Users\Pieter\Desktop\Excel 2013.lnk

!ENTRY org.eclipse.osgi 4 0 2015-03-17 15:54:11.852
!MESSAGE Application error
!STACK 1
org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4467)
	at org.eclipse.swt.SWT.error(SWT.java:4356)
	at org.eclipse.swt.SWT.error(SWT.java:4327)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:476)
	at org.eclipse.swt.widgets.Control.createHandle(Control.java:703)
	at org.eclipse.swt.widgets.Composite.createHandle(Composite.java:306)
	at org.eclipse.swt.widgets.Control.createWidget(Control.java:743)
	at org.eclipse.swt.widgets.Scrollable.createWidget(Scrollable.java:133)
	at org.eclipse.swt.widgets.Control.<init>(Control.java:111)
	at org.eclipse.swt.widgets.Scrollable.<init>(Scrollable.java:74)
	at org.eclipse.swt.widgets.Composite.<init>(Composite.java:96)
	at org.eclipse.ui.splash.BasicSplashHandler.getBundleProgressMonitor(BasicSplashHandler.java:183)
	at org.eclipse.ui.splash.BasicSplashHandler.getContent(BasicSplashHandler.java:290)
	at org.eclipse.ui.internal.splash.EclipseSplashHandler.init(EclipseSplashHandler.java:102)
	at org.eclipse.ui.internal.Workbench$6.run(Workbench.java:817)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.Workbench.createSplashWrapper(Workbench.java:839)
	at org.eclipse.ui.internal.Workbench.access$5(Workbench.java:753)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
!SESSION 2015-03-18 10:43:27.605 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-18 10:43:49.522
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-18 10:43:49.545
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-18 17:49:17.280 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-18 17:49:36.785
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-18 17:49:36.786
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 4 0 2015-03-18 17:50:56.829
!MESSAGE Failed to refresh projects from index changes
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Errors occurred while refreshing resources with the local file system.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.refreshResource(FileSystemResourceManager.java:923)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.refresh(FileSystemResourceManager.java:904)
	at org.eclipse.core.internal.resources.Resource.refreshLocal(Resource.java:1705)
	at org.eclipse.egit.ui.Activator$ResourceRefreshJob.runInWorkspace(Activator.java:357)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:38)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Contains: The project description file (.project) for '0506UnrestrictedAssociations' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!SUBENTRY 1 org.eclipse.core.resources 4 271 2015-03-18 17:50:56.844
!MESSAGE Errors occurred while refreshing resources with the local file system.
!SUBENTRY 2 org.eclipse.core.resources 4 567 2015-03-18 17:50:56.844
!MESSAGE The project description file (.project) for '0506UnrestrictedAssociations' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.

!ENTRY org.eclipse.egit.ui 4 0 2015-03-18 17:50:56.891
!MESSAGE Errors occurred while refreshing resources with the local file system.

!ENTRY org.eclipse.egit.ui 4 0 2015-03-18 17:50:57.016
!MESSAGE Failed to refresh projects from index changes
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Errors occurred while refreshing resources with the local file system.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.refreshResource(FileSystemResourceManager.java:923)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.refresh(FileSystemResourceManager.java:904)
	at org.eclipse.core.internal.resources.Resource.refreshLocal(Resource.java:1705)
	at org.eclipse.egit.ui.Activator$ResourceRefreshJob.runInWorkspace(Activator.java:357)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:38)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Contains: The project description file (.project) for '04RestrictedAssociations' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!SUBENTRY 1 org.eclipse.core.resources 4 271 2015-03-18 17:50:57.016
!MESSAGE Errors occurred while refreshing resources with the local file system.
!SUBENTRY 2 org.eclipse.core.resources 4 567 2015-03-18 17:50:57.016
!MESSAGE The project description file (.project) for '04RestrictedAssociations' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.

!ENTRY org.eclipse.egit.ui 4 0 2015-03-18 17:50:57.032
!MESSAGE Errors occurred while refreshing resources with the local file system.

!ENTRY org.eclipse.egit.ui 4 0 2015-03-18 17:50:58.923
!MESSAGE Failed to refresh projects from index changes
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Errors occurred while refreshing resources with the local file system.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.refreshResource(FileSystemResourceManager.java:923)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.refresh(FileSystemResourceManager.java:904)
	at org.eclipse.core.internal.resources.Resource.refreshLocal(Resource.java:1705)
	at org.eclipse.egit.ui.Activator$ResourceRefreshJob.runInWorkspace(Activator.java:357)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:38)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Contains: The project description file (.project) for '07PolymorphismStart' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!SUBENTRY 1 org.eclipse.core.resources 4 271 2015-03-18 17:50:58.923
!MESSAGE Errors occurred while refreshing resources with the local file system.
!SUBENTRY 2 org.eclipse.core.resources 4 567 2015-03-18 17:50:58.923
!MESSAGE The project description file (.project) for '07PolymorphismStart' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.

!ENTRY org.eclipse.egit.ui 4 0 2015-03-18 17:50:58.923
!MESSAGE Errors occurred while refreshing resources with the local file system.

!ENTRY org.eclipse.egit.ui 4 0 2015-03-18 17:51:00.079
!MESSAGE Failed to refresh projects from index changes
!STACK 1
org.eclipse.core.internal.resources.ResourceException: Errors occurred while refreshing resources with the local file system.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.refreshResource(FileSystemResourceManager.java:923)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.refresh(FileSystemResourceManager.java:904)
	at org.eclipse.core.internal.resources.Resource.refreshLocal(Resource.java:1705)
	at org.eclipse.egit.ui.Activator$ResourceRefreshJob.runInWorkspace(Activator.java:357)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:38)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Contains: The project description file (.project) for 'les_4' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!SUBENTRY 1 org.eclipse.core.resources 4 271 2015-03-18 17:51:00.079
!MESSAGE Errors occurred while refreshing resources with the local file system.
!SUBENTRY 2 org.eclipse.core.resources 4 567 2015-03-18 17:51:00.079
!MESSAGE The project description file (.project) for 'les_4' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.

!ENTRY org.eclipse.egit.ui 4 0 2015-03-18 17:51:00.079
!MESSAGE Errors occurred while refreshing resources with the local file system.

!ENTRY org.eclipse.ui.ide 4 4 2015-03-18 17:51:07.017
!MESSAGE Problems saving workspace

!ENTRY org.eclipse.ui.ide 2 1 2015-03-18 17:51:07.017
!MESSAGE Problems occurred while trying to save the state of the workbench.
!SUBENTRY 1 org.eclipse.core.resources 2 234 2015-03-18 17:51:07.017
!MESSAGE The project description file (.project) for '04RestrictedAssociations' was missing.  This file contains important information about the project.  A new project description file has been created, but some information about the project may have been lost.
!SUBENTRY 1 org.eclipse.core.resources 2 234 2015-03-18 17:51:07.017
!MESSAGE The project description file (.project) for '0506UnrestrictedAssociations' was missing.  This file contains important information about the project.  A new project description file has been created, but some information about the project may have been lost.
!SUBENTRY 1 org.eclipse.core.resources 2 234 2015-03-18 17:51:07.017
!MESSAGE The project description file (.project) for '07PolymorphismStart' was missing.  This file contains important information about the project.  A new project description file has been created, but some information about the project may have been lost.
!SUBENTRY 1 org.eclipse.core.resources 2 234 2015-03-18 17:51:07.017
!MESSAGE The project description file (.project) for 'les_4' was missing.  This file contains important information about the project.  A new project description file has been created, but some information about the project may have been lost.
!SESSION 2015-03-18 17:51:08.517 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-18 17:51:19.025
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-18 17:51:19.025
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.core 4 0 2015-03-18 17:51:19.229
!MESSAGE Git team provider configuration has gone missing.
!STACK 0
java.io.FileNotFoundException: C:\Users\Pieter\Documents\mario\.metadata\.plugins\org.eclipse.core.resources\.projects\04RestrictedAssociations\org.eclipse.egit.core\GitProjectData.properties (Het systeem kan het opgegeven bestand niet vinden)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.<init>(Unknown Source)
	at org.eclipse.egit.core.project.GitProjectData.load(GitProjectData.java:448)
	at org.eclipse.egit.core.project.GitProjectData.get(GitProjectData.java:204)
	at org.eclipse.egit.core.GitProvider.getData(GitProvider.java:86)
	at org.eclipse.egit.core.GitProvider.getMoveDeleteHook(GitProvider.java:73)
	at org.eclipse.team.internal.core.MoveDeleteManager.getHookFor(MoveDeleteManager.java:34)
	at org.eclipse.team.internal.core.MoveDeleteManager.deleteProject(MoveDeleteManager.java:74)
	at org.eclipse.core.internal.resources.Resource.unprotectedDelete(Resource.java:1986)
	at org.eclipse.core.internal.resources.Resource.delete(Resource.java:803)
	at org.eclipse.core.internal.resources.Project.delete(Project.java:344)
	at org.eclipse.ltk.core.refactoring.resource.DeleteResourceChange.perform(DeleteResourceChange.java:160)
	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:278)
	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:278)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation$1.run(PerformChangeOperation.java:258)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2313)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.executeChange(PerformChangeOperation.java:306)
	at org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation.executeChange(UIPerformChangeOperation.java:92)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:218)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2313)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
!SESSION 2015-03-19 13:40:30.226 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-19 13:40:51.614
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-19 13:40:51.637
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-20 16:17:17.053 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-20 16:17:43.904
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-20 16:17:43.906
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-22 12:41:44.093 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-22 12:42:33.355
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-22 12:42:33.417
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-22 21:25:56.578 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-22 21:26:23.077
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-22 21:26:23.078
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-23 18:41:18.521 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-23 18:41:50.298
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-23 18:41:50.338
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-25 10:40:25.037 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-25 10:41:27.013
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-25 10:41:27.091
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-26 13:51:06.733 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.core.resources 4 567 2015-03-26 13:51:10.364
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2015-03-26 13:51:10.364
!MESSAGE Could not read metadata for 'les 8'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException: The project description file (.project) for 'les 8' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:851)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:884)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:864)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:715)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1565)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2464)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2219)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:447)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:771)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:764)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:721)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:936)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:319)
	at org.eclipse.osgi.container.Module.doStart(Module.java:571)
	at org.eclipse.osgi.container.Module.start(Module.java:439)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:454)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:107)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:531)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:324)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:320)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:36)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:391)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:337)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:160)
	at java.lang.ClassLoader.loadClass(Unknown Source)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:136)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2015-03-26 13:51:10.395
!MESSAGE The project description file (.project) for 'les 8' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2015-03-26 13:51:10.395
!MESSAGE Could not read metadata for 'les_4'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException: The project description file (.project) for 'les_4' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:851)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:884)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:864)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:715)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1565)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2464)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2219)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:447)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:771)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:764)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:721)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:936)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:319)
	at org.eclipse.osgi.container.Module.doStart(Module.java:571)
	at org.eclipse.osgi.container.Module.start(Module.java:439)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:454)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:107)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:531)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:324)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:320)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:36)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:391)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:345)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:337)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:160)
	at java.lang.ClassLoader.loadClass(Unknown Source)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:136)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2015-03-26 13:51:10.396
!MESSAGE The project description file (.project) for 'les_4' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-26 13:51:30.935
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-26 13:51:30.936
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.e4.ui.workbench 4 0 2015-03-26 13:51:33.133
!MESSAGE Error setting focus to : org.eclipse.e4.ui.model.application.ui.basic.impl.PartImpl Operator.java
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4441)
	at org.eclipse.swt.SWT.error(SWT.java:4356)
	at org.eclipse.swt.SWT.error(SWT.java:4327)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:476)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:348)
	at org.eclipse.swt.widgets.Control.setFocus(Control.java:3320)
	at org.eclipse.swt.widgets.Composite.setFocus(Composite.java:1039)
	at org.eclipse.swt.widgets.Composite.setFocus(Composite.java:1039)
	at org.eclipse.ui.texteditor.StatusTextEditor.setFocus(StatusTextEditor.java:120)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.setFocus(JavaEditor.java:2389)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.delegateSetFocus(CompatibilityPart.java:191)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:253)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:225)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:107)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.focusGui(PartRenderingEngine.java:795)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer$2.setFocus(ContributedPartRenderer.java:100)
	at org.eclipse.swt.custom.CTabItem.setFocus(CTabItem.java:332)
	at org.eclipse.swt.custom.CTabFolder.setFocus(CTabFolder.java:2555)
	at org.eclipse.swt.widgets.Control.fixFocus(Control.java:1052)
	at org.eclipse.swt.widgets.Control.setVisible(Control.java:3818)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3098)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3055)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1260)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer$1.handleEvent(LazyStackRenderer.java:68)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler$1.run(UIEventHandler.java:40)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:187)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:156)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4734)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:218)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:36)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:81)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:59)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:171)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1247)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1204)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.closePart(StackRenderer.java:1222)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.access$3(StackRenderer.java:1204)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer$12.close(StackRenderer.java:1095)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1874)
	at org.eclipse.swt.custom.CTabFolder$1.handleEvent(CTabFolder.java:288)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4353)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4172)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3761)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.e4.ui.workbench 4 0 2015-03-26 13:51:34.215
!MESSAGE Error setting focus to : org.eclipse.e4.ui.model.application.ui.basic.impl.PartImpl Operator.java
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4441)
	at org.eclipse.swt.SWT.error(SWT.java:4356)
	at org.eclipse.swt.SWT.error(SWT.java:4327)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:476)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:348)
	at org.eclipse.swt.widgets.Control.setFocus(Control.java:3320)
	at org.eclipse.swt.widgets.Composite.setFocus(Composite.java:1039)
	at org.eclipse.swt.widgets.Composite.setFocus(Composite.java:1039)
	at org.eclipse.ui.texteditor.StatusTextEditor.setFocus(StatusTextEditor.java:120)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.setFocus(JavaEditor.java:2389)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.delegateSetFocus(CompatibilityPart.java:191)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:253)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:225)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:107)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.focusGui(PartRenderingEngine.java:795)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer$2.setFocus(ContributedPartRenderer.java:100)
	at org.eclipse.swt.custom.CTabItem.setFocus(CTabItem.java:332)
	at org.eclipse.swt.custom.CTabFolder.setFocus(CTabFolder.java:2555)
	at org.eclipse.swt.widgets.Control.fixFocus(Control.java:1052)
	at org.eclipse.swt.widgets.Control.setVisible(Control.java:3818)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3098)
	at org.eclipse.swt.custom.CTabFolder.setSelection(CTabFolder.java:3055)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.showTab(StackRenderer.java:1260)
	at org.eclipse.e4.ui.workbench.renderers.swt.LazyStackRenderer$1.handleEvent(LazyStackRenderer.java:68)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler$1.run(UIEventHandler.java:40)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:187)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:156)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4734)
	at org.eclipse.e4.ui.internal.workbench.swt.E4Application$1.syncExec(E4Application.java:218)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:36)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:197)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:135)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:78)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:39)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:81)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:59)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:171)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1247)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.hidePart(PartServiceImpl.java:1204)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.closePart(StackRenderer.java:1222)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer.access$3(StackRenderer.java:1204)
	at org.eclipse.e4.ui.workbench.renderers.swt.StackRenderer$12.close(StackRenderer.java:1095)
	at org.eclipse.swt.custom.CTabFolder.onMouse(CTabFolder.java:1874)
	at org.eclipse.swt.custom.CTabFolder$1.handleEvent(CTabFolder.java:288)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4353)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4172)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3761)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
!SESSION 2015-03-27 19:51:39.417 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-27 19:52:16.577
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-27 19:52:16.629
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2015-03-30 17:31:12.951 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-30 17:31:41.444
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-30 17:31:41.494
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.ui 4 10001 2015-03-30 22:02:40.367
!MESSAGE Internal Error
!STACK 0
org.eclipse.jface.text.BadLocationException: First position: 'xdifference;' at 2410, this position: 'difference;' at 3939
	at org.eclipse.jface.text.link.LinkedPositionGroup.enforceEqualContent(LinkedPositionGroup.java:132)
	at org.eclipse.jface.text.link.LinkedPositionGroup.addPosition(LinkedPositionGroup.java:113)
	at org.eclipse.jdt.internal.ui.refactoring.reorg.RenameLinkedMode.start(RenameLinkedMode.java:254)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RenameJavaElementAction.run(RenameJavaElementAction.java:212)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RenameJavaElementAction.doRun(RenameJavaElementAction.java:159)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RenameJavaElementAction.run(RenameJavaElementAction.java:138)
	at org.eclipse.jdt.ui.actions.RenameAction.run(RenameAction.java:118)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:279)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:251)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:519)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:122)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)
	at sun.reflect.GeneratedMethodAccessor41.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:229)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:149)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1085)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1070)
	at org.eclipse.swt.widgets.Control.traverse(Control.java:4106)
	at org.eclipse.swt.widgets.Control.translateMnemonic(Control.java:3948)
	at org.eclipse.swt.widgets.Composite.translateMnemonic(Composite.java:1205)
	at org.eclipse.swt.widgets.Control.translateMnemonic(Control.java:3966)
	at org.eclipse.swt.widgets.Display.translateMnemonic(Display.java:4823)
	at org.eclipse.swt.widgets.Display.filterMessage(Display.java:1276)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.ui 4 10001 2015-03-30 22:02:48.094
!MESSAGE Internal Error
!STACK 0
org.eclipse.jface.text.BadLocationException: First position: 'xdifference;' at 2410, this position: 'difference;' at 3939
	at org.eclipse.jface.text.link.LinkedPositionGroup.enforceEqualContent(LinkedPositionGroup.java:132)
	at org.eclipse.jface.text.link.LinkedPositionGroup.addPosition(LinkedPositionGroup.java:113)
	at org.eclipse.jdt.internal.ui.refactoring.reorg.RenameLinkedMode.start(RenameLinkedMode.java:254)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RenameJavaElementAction.run(RenameJavaElementAction.java:212)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RenameJavaElementAction.doRun(RenameJavaElementAction.java:159)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RenameJavaElementAction.run(RenameJavaElementAction.java:138)
	at org.eclipse.jdt.ui.actions.RenameAction.run(RenameAction.java:118)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:279)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:251)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:519)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:122)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)
	at sun.reflect.GeneratedMethodAccessor41.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:229)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:149)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1085)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1070)
	at org.eclipse.swt.widgets.Control.traverse(Control.java:4106)
	at org.eclipse.swt.widgets.Control.translateMnemonic(Control.java:3948)
	at org.eclipse.swt.widgets.Composite.translateMnemonic(Composite.java:1205)
	at org.eclipse.swt.widgets.Control.translateMnemonic(Control.java:3966)
	at org.eclipse.swt.widgets.Display.translateMnemonic(Display.java:4823)
	at org.eclipse.swt.widgets.Display.filterMessage(Display.java:1276)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3757)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.ui 4 10001 2015-03-30 22:02:58.642
!MESSAGE Internal Error
!STACK 0
org.eclipse.jface.text.BadLocationException: First position: 'xdifference;' at 2410, this position: 'difference;' at 3939
	at org.eclipse.jface.text.link.LinkedPositionGroup.enforceEqualContent(LinkedPositionGroup.java:132)
	at org.eclipse.jface.text.link.LinkedPositionGroup.addPosition(LinkedPositionGroup.java:113)
	at org.eclipse.jdt.internal.ui.refactoring.reorg.RenameLinkedMode.start(RenameLinkedMode.java:254)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RenameJavaElementAction.run(RenameJavaElementAction.java:212)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RenameJavaElementAction.doRun(RenameJavaElementAction.java:159)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RenameJavaElementAction.run(RenameJavaElementAction.java:138)
	at org.eclipse.jdt.ui.actions.RenameAction.run(RenameAction.java:118)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:279)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:251)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:519)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:595)
	at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:511)
	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:420)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4353)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4172)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3761)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
!SESSION 2015-03-31 13:42:26.371 -----------------------------------------------
eclipse.buildId=4.4.1.M20140925-0400
java.version=1.8.0_31
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=nl_BE
Framework arguments:  -product org.eclipse.epp.package.standard.product
Command-line arguments:  -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.standard.product

!ENTRY org.eclipse.egit.ui 2 0 2015-03-31 13:42:52.873
!MESSAGE Warning: EGit couldn't detect the installation path "gitPrefix" of native Git. Hence EGit can't respect system level
Git settings which might be configured in ${gitPrefix}/etc/gitconfig under the native Git installation directory.
The most important of these settings is core.autocrlf. Git for Windows by default sets this parameter to true in
this system level configuration. The Git installation location can be configured on the
Team > Git > Configuration preference page's 'System Settings' tab.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.egit.ui 2 0 2015-03-31 13:42:52.904
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Pieter'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 14:30:46.298
!MESSAGE Could not retrieve declared methods
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.lookup.TypeSystem.getWildcard(TypeSystem.java:250)
	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getWildcard(AnnotatableTypeSystem.java:195)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getTypeFromVariantTypeSignature(LookupEnvironment.java:1491)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getTypeArgumentsFromSignature(LookupEnvironment.java:1170)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getTypeFromTypeSignature(LookupEnvironment.java:1436)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.createMethod(BinaryTypeBinding.java:703)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.createMethods(BinaryTypeBinding.java:816)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.cachePartsFrom(BinaryTypeBinding.java:474)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:696)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:679)
	at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:299)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:140)
	at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:99)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:180)
	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.resolve(ParameterizedTypeBinding.java:1024)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:158)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveTypesFor(BinaryTypeBinding.java:1409)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.methods(BinaryTypeBinding.java:1363)
	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.methods(ParameterizedTypeBinding.java:951)
	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.availableMethods(ReferenceBinding.java:229)
	at org.eclipse.jdt.core.dom.TypeBinding.getDeclaredMethods(TypeBinding.java:289)
	at org.eclipse.jdt.internal.corext.dom.ScopeAnalyzer.addInherited(ScopeAnalyzer.java:195)
	at org.eclipse.jdt.internal.corext.dom.ScopeAnalyzer.getDeclarationsInScope(ScopeAnalyzer.java:365)
	at org.eclipse.jdt.internal.ui.text.correction.UnresolvedElementsSubProcessor.getMethodProposals(UnresolvedElementsSubProcessor.java:1022)
	at org.eclipse.jdt.internal.ui.text.correction.QuickFixProcessor.process(QuickFixProcessor.java:340)
	at org.eclipse.jdt.internal.ui.text.correction.QuickFixProcessor.getCorrections(QuickFixProcessor.java:312)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionCollector.safeRun(JavaCorrectionProcessor.java:378)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.run(JavaCorrectionProcessor.java:339)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.process(JavaCorrectionProcessor.java:335)
	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectCorrections(JavaCorrectionProcessor.java:468)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:225)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:199)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:285)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:186)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1181)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1150)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:902)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:243)
	at org.eclipse.jface.text.TextViewerHoverManager$5.run(TextViewerHoverManager.java:233)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4147)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3764)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)
	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:41.867
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:41.867
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:41.867
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:41.898
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:41.914
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:41.914
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:41.929
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:41.929
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:41.929
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:41.961
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:41.961
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:41.961
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:41.992
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:41.992
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:41.992
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:42.008
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:42.008
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:42.008
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:42.039
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:42.039
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:42.039
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:42.054
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:42.054
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:42.054
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:42.070
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:42.070
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:42.070
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:42.101
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:42.101
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:42.101
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:42.117
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:42.117
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:42.117
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:42.148
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:42.148
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:42.148
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:42.164
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:42.164
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:42.164
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:42.195
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:42.195
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:42.195
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:42.211
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:42.211
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:42.211
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:42.226
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:42.226
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:42.226
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:42.242
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:42.242
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:42.258
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:42.273
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:42.273
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:42.273
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:42.289
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:42.289
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:42.289
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:42.304
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:42.304
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:42.304
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:42.320
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:42.336
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:42.336
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:42.351
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:42.351
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:42.351
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:42.367
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:42.367
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:42.367
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:42.383
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:42.383
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:42.383
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:42.398
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:42.398
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:42.398
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:42.414
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:42.429
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:42.429
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:42.445
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 2 2015-03-31 18:59:42.445
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.ui 4 0 2015-03-31 18:59:42.445
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)

!ENTRY org.eclipse.jdt.core 4 4 2015-03-31 18:59:42.461
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package jumpingalien.model;

import java.util.List;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;

import be.kuleuven.cs.som.annotate.Raw;
import jumpingalien.part2.facade.IFacadePart2;


public class World {
	

	/**
	 * Create a new world with the given parameters.
	 * 
	 * @param tileSize
	 *            Length (in pixels) of a side of each square tile in the world
	 * @param nbTilesX
	 *            Number of tiles in the horizontal direction
	 * @param nbTilesY
	 *            Number of tiles in the vertical direction
	 * @param visibleWindowWidth
	 *            Width of the visible window, in pixels
	 * @param visibleWindowHeight
	 *            Height of the visible window, in pixels
	 * @param targetTileX
	 *            Tile x-coordinate of the target tile of the created world
	 * @param targetTileY
	 *            Tile y-coordinate of the target tile of the created world
	 */
	public World(int tileSize, int nbTilesX, int nbTilesY,
			int visibleWindowWidth, int visibleWindowHeight, int targetTileX,
			int targetTileY) 
		throws IllegalAmountOfCharactersException,
				IllegalTileSizeException, IllegalTargetTileException,
				IllegalVisibleWindowException {
			if ( ! isValidAmountOfCharacters())
				throw new  IllegalAmountOfCharactersException();
			if ( ! isValidTileSize(tileSize))
				throw new  IllegalTileSizeException(tileSize);
			if ( ! isValidTargetTile(targetTileX, targetTileY))
				throw new  IllegalTargetTileException(targetTileX, targetTileY);
			if ( ! isValidVisibleWindow(visibleWindowWidth, visibleWindowHeight,tileSize, getNbTilesX(), getNbTilesY()))
				throw new  IllegalVisibleWindowException(visibleWindowWidth, visibleWindowHeight);
		// TODO illegaltilesizeecxeption, illegalsetarget..., illegalvis... toevoegen
		this.setTileSize(tileSize);
		this.setNbTilesX(nbTilesX);
		this.setNbTilesY(nbTilesY);
		this.setVisibleWindowWidth(visibleWindowWidth);
		this.setVisibleWindowHeight(visibleWindowHeight);
		this.setTargetTileX(targetTileX);
		this.setTargetTileY(targetTileY);
		this.geologicalFeature = new int[nbTilesY][nbTilesX];
		while (i < nbTilesX - 1) {
			while (j < nbTilesY - 1) {
				this.setGeologicalFeature(i * tileSize, j * tileSize, AIR);
				j++;
			}
			i++;
			this.setJ(0);
		}
			
	}
	
	

	private int tileSize;
	private int nbTilesX;
	private int nbTilesY;
	private int visibleWindowWidth;
	private int visibleWindowHeight;
	private int targetTileX;
	private int targetTileY;
	private int XVisibleWindow;
	private int YVisibleWindow;
	private int[][] geologicalFeature;// = new int[this.nbTilesY][this.nbTilesX];
	private Mazub alien;
	private int i = 0;
	private int j = 0;
	

	private List<Shark> sharks = new CopyOnWriteArrayList<Shark>();
	private List<Plant> plants = new CopyOnWriteArrayList<Plant>();
	private List<Slime> slimes = new CopyOnWriteArrayList<Slime>();


	
	
//	GETTERS
	/**
	 * Returns the size of the given game world, in number of pixels.
	 * 
	 * @return The size of the game world, in pixels, as an array of two
	 *         elements: width (X) and height (Y), in that order.
	 */
	public int[] getWorldSizeInPixels() {
		return new int[] {getX(),getY()};
	}
	
	/**
	 * Returns the length of a square tile side in the given world.
	 * 
	 * @return The length of a square tile side, expressed as a number of
	 *         pixels.
	 */
	public int getTileLength() {
		return this.tileSize;
	}
	
	
	/**
	 * @return the nbTilesX
	 */
	private int getNbTilesX() {
		return nbTilesX;
	}

	/**
	 * @return the nbTilesY
	 */
	private int getNbTilesY() {
		return nbTilesY;
	}

	/**
	 * @return the visibleWindowWidth
	 */
	private int getVisibleWindowWidth() {
		return visibleWindowWidth;
	}

	/**
	 * @return the visibleWindowHeight
	 */
	private int getVisibleWindowHeight() {
		return visibleWindowHeight;
	}

	/**
	 * @return the targetTileX
	 */
	private int getTargetTileX() {
		return targetTileX;
	}

	/**
	 * @return the targetTileY
	 */
	private int getTargetTileY() {
		return targetTileY;
	}

	/**
	 * Return the coordinates of the rectangular visible window that moves
	 * together with Mazub.
	 * 
	 * @return The pixel coordinates of the visible window, in the order
	 *         <b>left, bottom, right, top</b>.
	 */
	public int[] getVisibleWindow() {
		return new int[] {this.getXVisibleWindow(), this.getYVisibleWindow(),
				this.getXVisibleWindow() + this.getVisibleWindowWidth(),
				this.getYVisibleWindow() + this.getVisibleWindowHeight()};
	}
	
	private Mazub getAlien() {
		return this.alien;
	}
	
	
	/**
	 * Returns the bottom left pixel coordinate of the tile at the given tile
	 * position.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile
	 * @param tileY
	 *            The y-position y_T of the tile
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *         bottom left pixel of the given tile, in that order.
	 */
	public int[] getBottomLeftPixelOfTile(int tileX, int tileY) {
		return new int[] {tileX * this.getTileLength(),
				tileY * this.getTileLength()};
	}
		
	/**
	 * Returns the tile coordinate of the tile at the given pixels.
	 * 
	 * @param pixelX
	 *            The x-pixel
	 * @param pixelY
	 *            The y-pixel
	 * @return An array which contains the x-coordinate and y-coordinate of the
	 *          given tile, in that order.
	 */
	private int[] getTileOfPixels(int pixelX, int pixelY) {
		return new int[] {(pixelX - pixelX % this.getTileLength())/this.getTileLength(),
				(pixelY - pixelY % this.getTileLength())/this.getTileLength()};
	}
	
	
	
	/**
	 * Returns the tile positions of all tiles within the given rectangular
	 * region.
	 * 
	 * @param pixelLeft
	 *            The x-coordinate of the left side of the rectangular region.
	 * @param pixelBottom
	 *            The y-coordinate of the bottom side of the rectangular region.
	 * @param pixelRight
	 *            The x-coordinate of the right side of the rectangular region.
	 * @param pixelTop
	 *            The y-coordinate of the top side of the rectangular region.
	 * 
	 * @return An array of tile positions, where each position (x_T, y_T) is
	 *         represented as an array of 2 elements, containing the horizontal
	 *         (x_T) and vertical (y_T) coordinate of a tile in that order.
	 *         The returned array is ordered from left to right,
	 *         bottom to top: all positions of the bottom row (ordered from
	 *         small to large x_T) precede the positions of the row above that.
	 * 
	 */
	public int[][] getTilePositionsIn(int pixelLeft, int pixelBottom,
			int pixelRight, int pixelTop) {
		int posLeft = this.getTileOfPixels(pixelLeft,pixelBottom)[0];
		int posBottom = this.getTileOfPixels(pixelLeft,pixelBottom)[1];
		int posRight = this.getTileOfPixels(pixelRight,pixelTop)[0];
		int posTop = this.getTileOfPixels(pixelRight,pixelTop)[1];
		
		int[][] array = new int[(posRight - posLeft + 1) * (posTop - posBottom +1)][2];
		
		int counter = 0;
		for (int i=posBottom;i <= posTop;i++ ) {
			for (int j=posLeft;j <= posRight;j++){
				array[counter][0] = j;
				array[counter][1] = i;
				counter++;
			}
		}
		return array;
	}
	
	/**
	 * Returns the geological feature of the tile with its bottom left pixel at
	 * the given position.
	 * 
	 * @param world
	 *            The world containing the tile for which the
	 *            geological feature should be returned.
	 * 
	 * @param pixelX
	 *            The x-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * @param pixelY
	 *            The y-position of the pixel at the bottom left of the tile for
	 *            which the geological feature should be returned.
	 * 
	 * @return The type of the tile with the given bottom left pixel position,
	 *         where
	 *         <ul>
	 *         <li>the value 0 is returned for an <b>air</b> tile;</li>
	 *         <li>the value 1 is returned for a <b>solid ground</b> tile;</li>
	 *         <li>the value 2 is returned for a <b>water</b> tile;</li>
	 *         <li>the value 3 is returned for a <b>magma</b> tile.</li>
	 *         </ul>
	 * 
	 * @note This method must return its result in constant time.
	 * 
	 * @throw IllegalPixelException if the given position does not correspond to the
	 *        bottom left pixel of a tile.
	 */
//  TODO exception maken
	public int getGeologicalFeature(int pixelX, int pixelY)
			throws IllegalPixelException {
				if(!isValidBottomLeftPixel(pixelX, pixelY))
					throw new IllegalPixelException(pixelX,pixelY);
		return this.geologicalFeature[pixelY/this.getTileLength()][pixelX/this.getTileLength()];
	}
	
	/**
	 * 
	 * @return
	 */
	public int getX() {
		return this.getNbTilesX() * this.getTileLength();
	}
	
	/**
	 * 
	 * @return
	 */
	public int getY() {
		return this.getNbTilesY() * this.getTileLength();
	}
	
//	public Collection<Mazub> getMazubs() {
//		return this.mazubs;
//	}
	public Collection<Plant> getPlants() {
		return this.plants;
	}
	public Collection<Shark> getSharks() {
		return this.sharks;
	}
	public Collection<Slime> getSlimes() {
		return this.slimes;
	}
	
//	private int getNbMazubs() {
//		return mazubs.size();
//	}
	private int getNbPlants() {
		return plants.size();
	}
	private int getNbSharks() {
		return sharks.size();
	}
	private int getNbSlimes() {
		return slimes.size();
	}
//	SETTERS
	
	
	/**
	 * @return the xVisibleWindow
	 */
	private int getXVisibleWindow() {
		return XVisibleWindow;
	}

	/**
	 * @return the yVisibleWindow
	 */
	private int getYVisibleWindow() {
		return YVisibleWindow;
	}

	/**
	 * @param tileSize the tileSize to set
	 */
	private void setTileSize(int tileSize) {
		this.tileSize = tileSize;
	}

	/**
	 * @param nbTilesX the nbTilesX to set
	 */
	private void setNbTilesX(int nbTilesX) {
		this.nbTilesX = nbTilesX;
	}

	/**
	 * @param nbTilesY the nbTilesY to set
	 */
	private void setNbTilesY(int nbTilesY) {
		this.nbTilesY = nbTilesY;
	}

	/**
	 * @param visibleWindowWidth the visibleWindowWidth to set
	 */
	private void setVisibleWindowWidth(int visibleWindowWidth) {
		this.visibleWindowWidth = visibleWindowWidth;
	}

	/**
	 * @param visibleWindowHeight the visibleWindowHeight to set
	 */
	private void setVisibleWindowHeight(int visibleWindowHeight) {
		this.visibleWindowHeight = visibleWindowHeight;
	}

	/**
	 * @param targetTileX the targetTileX to set
	 */
	private void setTargetTileX(int targetTileX) {
		this.targetTileX = targetTileX;
	}

	/**
	 * @param targetTileY the targetTileY to set
	 */
	private void setTargetTileY(int targetTileY) {
		this.targetTileY = targetTileY;
	}
	
	/**
	 * @param xVisibleWindow the xVisibleWindow to set
	 */
	private void setXVisibleWindow(int xVisibleWindow) {
		XVisibleWindow = xVisibleWindow;
	}

	/**
	 * @param yVisibleWindow the yVisibleWindow to set
	 */
	private void setYVisibleWindow(int yVisibleWindow) {
		YVisibleWindow = yVisibleWindow;
	}
	
	private void setJ(int value) {
		this.j = value;
	}

	/**
	 * Modify the geological type of a specific tile in the given world to a
	 * given type.
	 * 
	 * @param tileX
	 *            The x-position x_T of the tile for which the type needs to be
	 *            modified
	 * @param tileY
	 *            The y-position y_T of the tile for which the type needs to be
	 *            modified
	 * @param tileType
	 *            The new type for the given tile, where
	 *            <ul>
	 *            <li>the value 0 is provided for an <b>air</b> tile;</li>
	 *            <li>the value 1 is provided for a <b>solid ground</b> tile;</li>
	 *            <li>the value 2 is provided for a <b>water</b> tile;</li>
	 *            <li>the value 3 is provided for a <b>magma</b> tile.</li>
	 *            </ul>
	 */
// 	TODO exception toevoegen
	public void setGeologicalFeature(int tileX, int tileY, enum tileType) {
		
		this.geologicalFeature[tileY][tileX] = tileType;
	}
	
	public void setAlien(Mazub alien) {
		this.alien = alien;
	}
	
	public void removeSlime(@Raw Slime slime) {
		assert this.hasSlime(slime);
		assert slime != null;
		this.slimes.remove(slime);
	}
	
	public void removePlant(@Raw Plant plant) {
		assert this.hasPlant(plant);
		assert plant != null;
		this.plants.remove(plant);
	}
	
	public void removeShark(@Raw Shark shark) {
		assert this.hasShark(shark);
		assert shark != null;
		this.sharks.remove(shark);
	}
	
	public void addSlime(Slime slime) {
		assert slime != null;
	    assert slime.getWorld() == this;
	    assert !this.hasSlime(slime);
		this.slimes.add(slime);
	}
	
	public void addShark(Shark shark) {
		assert shark != null;
	    assert shark.getWorld() == this;
	    assert !this.hasShark(shark);
		this.sharks.add(shark);
	}

	public void addPlant(Plant plant) {
//		assert plant != null;
//	    assert plant.getWorld() == this;
//	    assert !this.hasPlant(plant);
		this.plants.add(plant);
	}
	
	private boolean hasPlant(Plant plant) {
		return this.plants.contains(plant);
	}
	
	private boolean hasShark(Shark shark) {
		return this.sharks.contains(shark);
	}
	
	private boolean hasSlime(Slime slime) {
		return this.slimes.contains(slime);
	}
	
	
//	VALIDATIONS
	
	private boolean isValidTileSize(int tileSize){
		return tileSize > 0;
	}
	
	private boolean isValidNbTiles(int nbTiles){
		return nbTiles > 0;
	}
	
	// TODO
	private boolean isValidVisibleWindow(int visiblewindowWidth,int visibleWindowHeight,
				int tileSize, int nbTilesX, int nbTilesY){
		return true;// ((visiblewindowWidth <= tileSize * nbTilesX) && (visibleWindowHeight
				//<= tileSize * nbTilesY));
	}
	private boolean isValidBottomLeftPixel(int pixelX, int pixelY) {
		return (new int[] {pixelX, pixelY} == this.getBottomLeftPixelOfTile(pixelX, pixelY));
	}
	
	private boolean isValidAmountOfCharacters() {
		return true;
			//	((alien.getNbOfMazubs() > 1) && (plant.getNbOfPlants() + 
				//slime.getNbOfSlimes() + shark.getNbOfSharks() <= 100));
	}
	private boolean isValidTargetTile(int x, int y) {
		return true;
	}

	
	
	/**
	 * Starts the game that is played in the given world.
	 * After this method has been invoked, no further game objects will be added
	 * via {@link IFacadePart2#addPlant(World, Plant)},
	 * {@link IFacadePart2#addShark(World, Shark)},
	 * {@link IFacadePart2#addSlime(World, Slime)}, or
	 * {@link IFacadePart2#setMazub(World, Mazub)}), and no geological features
	 * will be changed via
	 * {@link IFacadePart2#setGeologicalFeature(World, int, int, int)}.
	 */
	public void startGame() {
		
	}
	
	/**
	 * Returns whether the game, played in the given game world, is over.
	 * The game is over when Mazub has died, or has reached the target tile.
	 * 
	 * @return true if the game is over, false otherwise.
	 */
	public boolean isGameOver() {
		return (this.getAlien().isDeath() || didPlayerWin());
	}
	
	/**
	 * Returns whether the game played in the given world has finished and the
	 * player has won. The player wins when Mazub has reached the target tile.
	 * 
	 * @return true if the game is over and the player has won; false otherwise.
	 */
	public boolean didPlayerWin() {
		
		return (this.getAlien().getLocation() == new int[] {this.getTargetTileX(),this.getTargetTileY()});
	}
	
	
	/**
	 * NO DOCUMENTATION MUST BE WORKED OUT
	 * @throws IllegalDtException 
	 */
// TODO uitzoeken hoe dit moet
	public void advanceTime(double dt) throws IllegalDtException {
		alien.advanceTime(dt);

//		Iterator<Plant> plantIter = plants.iterator();
//		while(plantIter.hasNext()) {
//			Plant plant = plantIter.next();
//			plant.advanceTime(dt);
//		}
		for (Plant plant : this.getPlants()) {
			 plant.advanceTime(dt);
		}
		for (Shark shark: this.getSharks()) {
			shark.advanceTime(dt);
		}
		for (Slime slime: this.getSlimes()) {
			slime.advanceTime(dt);
		}
	
		positioningVisibleWindow();
	}
	
	private void positioningVisibleWindow() {
		//x
		if (this.getAlien().getLocation()[0] < 200) {
			this.setXVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] > this.getX() - 200) {
			this.setXVisibleWindow(this.getX() - this.getVisibleWindowWidth());
		}
		else if (this.getAlien().getLocation()[0] - 200 < this.getXVisibleWindow()) {
			this.setXVisibleWindow(this.getAlien().getLocation()[0] - 200);
		}
		else if (this.getAlien().getLocation()[0] + this.getAlien().getSize()[0] + 200 >
				this.getXVisibleWindow() + this.getVisibleWindowWidth()){
			this.setXVisibleWindow(this.getAlien().getLocation()[0] +this.getAlien().getSize()[0]
								- this.getVisibleWindowWidth() + 200);
		}
		//y
		if (this.getAlien().getLocation()[1] < 200) {
			this.setYVisibleWindow(0);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] > this.getY() - 200) {
			this.setYVisibleWindow(this.getY() - this.getVisibleWindowHeight());
		}
		else if (this.getAlien().getLocation()[1] - 200 < this.getYVisibleWindow()) {
			this.setYVisibleWindow(this.getAlien().getLocation()[1] - 200);
		}
		else if (this.getAlien().getLocation()[1] + this.getAlien().getSize()[1] + 200 >
				this.getYVisibleWindow() + this.getVisibleWindowHeight()){
			this.setYVisibleWindow(this.getAlien().getLocation()[1] + this.getAlien().getSize()[1]
								- this.getVisibleWindowHeight() + 200);
		}
		
	}
	
	private double minimalDt;
	private double getMinimalDt() {
		return minimalDt;
	}
	private void setMinimalDt(double dt) {
		this.minimalDt = dt;
	}
	private double ownDt;
	private double getOwnDt() {
		return ownDt;
	}
	private void setOwnDt(double dt) {
		this.ownDt = dt;
	}
	
	/*
	private double computeOwnDt() {
		if (this.getXAcc() == 0 && this.getYAcc() == 0) {
			setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getYSpeed())));
		}
		else {
			if (this.getXAcc != 0) {
				setOwnDt(Math.min(100 / Math.abs(this.getXSpeed()), 100 / Math.abs(this.getXSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getXAcc() / 100) + Math.pow(Math.abs(this.getXSpeed() / 100), 2))
								- Math.abs(this.getXSpeed()/ 100)) / (Math.abs(this.getXAcc() / 100)) ));
			}
			else {
				setOwnDt(Math.min(100 / Math.abs(this.getYSpeed()), 100 / Math.abs(this.getYSpeed()), 
						(Math.sqrt(2 * Math.abs(this.getYAcc() / 100) + Math.pow(Math.abs(this.getYSpeed() / 100), 2))
								- Math.abs(this.getYSpeed()/ 100)) / (Math.abs(this.getYAcc() / 100)) ));			
			}
		}
	}
	// TODO dit maken
	private double computeDt() {
		this.setMinimalDt(alien.computeOwnDt());
//		for (Mazub alien : this.getAlien()) {
//			if (alien.computeOwnDt() < this.getMinimalDt()) {
//				this.setMinimalDt(alien.computeOwnDt());
//			}
//		}
		for (Plant plant : this.getPlants()) {
			if (plant.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(plant.getOwnDt());
			}
		}
		for (Shark shark: this.getSharks()) {
			if (shark.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(shark.getOwnDt());
			}
		}
		for (Slime slime: this.getSlimes()) {
			if (slime.computeOwnDt() < this.getMinimalDt()) {
				this.setMinimalDt(slime.getOwnDt());
			}
		}
		return this.getMinimalDt();
	}	
	*/
	

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1571)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:258)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToEnumDeclaration(ASTConverter.java:3187)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2894)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2726)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)
	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
